import numpy as np
import xarray as xr

from openmethane_prior.lib.grid.grid import Grid


def test_grid_attributes():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.dimensions == (8, 10)
    assert test_grid.shape == (10, 8)
    assert test_grid.origin_xy == (-4, -5)
    assert test_grid.cell_size == (1, 2)



def test_grid_cell_area():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.cell_area == 2.0

def test_grid_coords():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    cell_coords_x = test_grid.cell_coords_x()
    cell_coords_y = test_grid.cell_coords_y()

    assert len(cell_coords_x) == 8
    assert cell_coords_x[0] == test_grid.llc_center_xy[0]

    assert len(cell_coords_y) == 10
    assert cell_coords_y[0] == test_grid.llc_center_xy[1]

def test_grid_bounds():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    cell_bounds_x = test_grid.cell_bounds_x()
    cell_bounds_y = test_grid.cell_bounds_y()

    assert len(cell_bounds_x) == 9
    assert cell_bounds_x[0] == test_grid.origin_xy[0]

    assert len(cell_bounds_y) == 11
    assert cell_bounds_y[0] == test_grid.origin_xy[1]

def test_grid_lonlat_bounds(aust10km_grid):
    cell_bounds_lons, cell_bounds_lats = aust10km_grid.cell_bounds_lonlat()

    # spot check some cells
    assert list(zip(cell_bounds_lons[0, 0], cell_bounds_lats[0, 0])) == [
        (104.96293860625516, -44.766629033148384),
        (105.08344259589477, -44.78663508563181),
        (105.11154247745316, -44.70106585755431),
        (104.9911499141127, -44.68106935695354),
    ]
    assert list(zip(cell_bounds_lons[42, 89], cell_bounds_lats[42, 89])) == [
        (116.59521757719003, -42.544987516315324),
        (116.71481560699907, -42.55697659818492),
        (116.73101739397438, -42.46884830052819),
        (116.61153331444048, -42.456865603153744),
    ]

def test_grid_xy_to_lonlat():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    # default projection is in degrees, so lon/lat and x/y are the same
    np.testing.assert_allclose(test_grid.xy_to_lonlat(0, 0), (0, 0))
    np.testing.assert_allclose(test_grid.xy_to_lonlat(-1, 0), (-1, 0))
    np.testing.assert_allclose(test_grid.xy_to_lonlat(-120, 45), (-120, 45))

def test_grid_projection_coordinates():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    # projection center coords for all cells in the domain
    x_center_coords = test_grid.cell_coords_x()
    y_center_coords = test_grid.cell_coords_y()

    # choose a range of 10x10 coordinates within the domain to spot test, including upper and lower bounds
    x_test_coords = [0, *np.random.randint(test_grid.dimensions[0], size=8), test_grid.dimensions[0] - 1]
    y_test_coords = [0, *np.random.randint(test_grid.dimensions[1], size=8), test_grid.dimensions[1] - 1]

    # note: the coordinates generated by Grid using the pyproj projection have
    # been observed to drift by up to **5 meters** from the coordinates
    # generated by MCIP, due to the differences between MCIPs projection
    # algorithm and ours.
    drift_tolerance = 5 # meters

    for y in y_test_coords:
        for x in x_test_coords:
            # compare the coordinates generated by our Grid class with the
            # LON/LAT coords stored in the input domain file which was
            # generated by MCIP using the same grid parameters.
            expected_coords = (float(x_center_coords[x]), float(y_center_coords[y]))
            projected_coords = test_grid.lonlat_to_xy(*expected_coords)

            # check that our generated coordinates match the coords generated by MCIP
            np.testing.assert_allclose(projected_coords, expected_coords, atol=drift_tolerance)

def test_grid_valid_cell_coords():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid.valid_cell_coords(0, 0)
    assert test_grid.valid_cell_coords(1, 1)
    assert test_grid.valid_cell_coords(7, 0)
    assert test_grid.valid_cell_coords(0, 9)
    assert test_grid.valid_cell_coords(7, 9)

    assert not test_grid.valid_cell_coords(-1, 0)
    assert not test_grid.valid_cell_coords(0, -1)
    assert not test_grid.valid_cell_coords(0, 10)
    assert not test_grid.valid_cell_coords(8, 0)
    assert not test_grid.valid_cell_coords(8, 10)

    np.testing.assert_array_equal(test_grid.valid_cell_coords(
        np.array([0, 1, 7, 0, 7, -1]),
        np.array([0, 1, 0, 9, 9, 0]),
    ),
    [True, True, True, True, True, False],
    )

    test_coords_x = np.array([
        [0, 1, 7, 8],
        [0, 1, 7, 8],
        [0, 1, 7, 8],
    ])
    test_coords_y = np.array([
        [0, 1, 8, 9],
        [0, 1, 9, 10],
        [0, 1, 10, 11],
    ])

    np.testing.assert_array_equal(test_grid.valid_cell_coords(test_coords_x, test_coords_y), [
        [True, True, True, False],
        [True, True, True, False],
        [True, True, False, False],
    ])

def test_grid_xy_to_cell_index():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    # coords should be a tuple (int, int, bool)
    found = test_grid.xy_to_cell_index(-4, -5)
    assert found == (0, 0, True)
    assert type(found) == tuple

    found_x, found_y, found_mask = found
    assert type(found_x) == np.int64
    assert type(found_y) == np.int64
    assert type(found_mask) == np.bool_

    # set up a grid with a different projection so we can test lon/lat -> x/y conversion
    # using EPSG:7842, which is GDA2020:
    # center: 133.38 -34.51
    test_grid = Grid(
        dimensions=(80, 40),
        origin_xy=(-40000, -20000),
        cell_size=(1000, 1000), # EPSG:7842 (GDA2020) uses meters
        proj_params="EPSG:7844",
    )

    # multiple values as np.array
    np_result = test_grid.xy_to_cell_index(
        x=np.array([-39500, 1300, 35401]),
        y=np.array([-20000, -12345, -1]),
    )

    np.testing.assert_allclose(np_result, (
        [0, 41, 75],
        [0, 7, 19],
        [True, True, True],
    ))

    # multiple values as xr.DataArray
    xr_result = test_grid.xy_to_cell_index(
        x=xr.DataArray([-39500, 1300, 35401]),
        y=xr.DataArray([-20000, -12345, -1]),
    )

    np.testing.assert_allclose(xr_result, (
        [0, 41, 75],
        [0, 7, 19],
        [True, True, True],
    ))

    # some points outside the grid
    in_out = test_grid.xy_to_cell_index(
        x=np.array([-42500, 1300, 42401]),
        y=np.array([-20000, -12345, -1]),
    )
    np.testing.assert_allclose(in_out, (
        [-3, 41, 82],
        [0, 7, 19],
        [False, True, False],
    ))

def test_grid_lonlat_to_cell_index():
    test_grid = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    # coords should be a tuple (int, int, bool)
    found = test_grid.lonlat_to_cell_index(-4, -5)
    assert found == (0, 0, True)
    assert type(found) == tuple

    found_x, found_y, found_mask = found
    assert type(found_x) == np.int64
    assert type(found_y) == np.int64
    assert type(found_mask) == np.bool_

    # set up a grid with a different projection so we can test lon/lat -> x/y conversion
    # using EPSG:7844, which is GDA2020:
    # center: 133.38 -34.51
    # extent: 93.31, -60.55 x 173.34, -8.47
    test_grid = Grid(
        dimensions=(80, 40),
        origin_xy=(-40, -20),
        cell_size=(1, 1), # EPSG:7844 (GDA2020) uses degrees
        proj_params="EPSG:7844",
    )

    # multiple values as np.array
    np_result = test_grid.lonlat_to_cell_index(
        lon=np.array([-40.5, -40, 0, 39, 40]), # valid x coords -40 to 39
        lat=np.array([-20, -20, 0, 19, 20]), # valid y coords -20 to 19
    )

    np.testing.assert_allclose(np_result, (
        [-1, 0, 40, 79, 80],
        [0, 0, 20, 39, 40],
        [False, True, True, True, False],
    ))

    # multiple values as xr.DataArray
    xr_result = test_grid.lonlat_to_cell_index(
        lon=xr.DataArray([-40.5, -40, 0, 39, 40]),
        lat=xr.DataArray([-20, -20, 0, 19, 20]),
    )

    np.testing.assert_allclose(xr_result, (
        [-1, 0, 40, 79, 80],
        [0, 0, 20, 39, 40],
        [False, True, True, True, False],
    ))

def test_grid_eq():
    test_grid_a = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    test_grid_b = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )

    assert test_grid_a == test_grid_a
    assert test_grid_a == test_grid_b

    assert test_grid_a != Grid(dimensions=(9, 10), origin_xy=(-4, -5), cell_size=(1, 2))
    assert test_grid_a != Grid(dimensions=(8, 10), origin_xy=(0, -5), cell_size=(1, 2))
    assert test_grid_a != Grid(dimensions=(8, 10), origin_xy=(-4, -5), cell_size=(1, 1))
    assert test_grid_a != Grid(dimensions=(8, 10), origin_xy=(-4, -5), cell_size=(1, 2), proj_params="EPSG:7844")


def test_grid_is_aligned():
    test_grid_a = Grid(
        dimensions=(8, 10),
        origin_xy=(-4, -5),
        cell_size=(1, 2),
    )
    test_grid_b = Grid(
        dimensions=(24, 30),
        origin_xy=(-12, -15),
        cell_size=(1, 1),
    )

    assert test_grid_a.is_aligned(test_grid_a) # same grid
    assert test_grid_a.is_aligned(test_grid_b) # same projection

    test_grid_c = Grid(
        dimensions=(10, 10), origin_xy=(-5, -5), cell_size=(1, 1),
        proj_params=dict(
            proj="lcc",
            lat_1=-15.0,
            lat_2=-40.0,
            lat_0=-27.5,
            lon_0=132,
        ),
    )
    test_grid_d = Grid(
        dimensions=(10, 10), origin_xy=(-5, -5), cell_size=(1, 1),
        proj_params=dict(
            proj="lcc",
            lat_1=-15.0,
            lat_2=-40.0,
            lat_0=-27.5,
            lon_0=132,
            x_0=100,
            y_0=0,
        ),
    )

    assert test_grid_c.is_aligned(test_grid_d)
    assert not test_grid_c.is_aligned(test_grid_a)

    test_grid_e = Grid(
        dimensions=(10, 10), origin_xy=(-5, -5), cell_size=(1, 1),
        proj_params="EPSG:4188"
    )
    test_grid_f = Grid(
        dimensions=(10, 10), origin_xy=(-5, -5), cell_size=(1, 1),
        proj_params="EPSG:4299"
    )

    assert test_grid_e.is_aligned(test_grid_f) == False
